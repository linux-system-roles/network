# SPDX-License-Identifier: BSD-3-Clause
---
- name: Play for testing bond connection
  hosts: all
  vars:
    controller_profile: bond0
    controller_device: nm-bond
    port1_profile: bond0.0
    dhcp_interface1: test1
    port2_profile: bond0.1
    dhcp_interface2: test2
  tasks:
    - name: Test bond device
      block:
        - name: "INIT Prepare setup"
          debug:
            msg: "##################################################"
        - name: Import the task 'create_test_interfaces_with_dhcp.yml'
          import_tasks: tasks/create_test_interfaces_with_dhcp.yml
        - name: Import the task 'assert_device_present.yml'
          import_tasks: tasks/assert_device_present.yml
          vars:
            interface: "{{ dhcp_interface1 }}"
        - name: Import the task 'assert_device_present.yml'
          import_tasks: tasks/assert_device_present.yml
          vars:
            interface: "{{ dhcp_interface2 }}"
        - name: "Backup the /etc/resolv.conf for initscript"
          command: cp -vf /etc/resolv.conf /etc/resolv.conf.bak
          when:
            - network_provider == "initscripts"
          changed_when: false
        - name: "TEST Add Bond with 2 ports"
          debug:
            msg: "##################################################"
        - name: Import network role
          import_role:
            name: linux-system-roles.network
          vars:
            network_connections:
              # Create a bond controller
              - name: "{{ controller_profile }}"
                state: up
                type: bond
                interface_name: "{{ controller_device }}"
                bond:
                  mode: active-backup
                  miimon: 110
                ip:
                  route_metric4: 65535
              # add an ethernet to the bond
              - name: "{{ port1_profile }}"
                state: up
                type: ethernet
                interface_name: "{{ dhcp_interface1 }}"
                controller: "{{ controller_profile }}"
              # add a second ethernet to the bond
              - name: "{{ port2_profile }}"
                state: up
                type: ethernet
                interface_name: "{{ dhcp_interface2 }}"
                controller: "{{ controller_profile }}"
        - name: Import the task 'assert_device_present.yml'
          import_tasks: tasks/assert_device_present.yml
          vars:
            interface: "{{ controller_device }}"
        - name: Include the task 'assert_profile_present.yml'
          include_tasks: tasks/assert_profile_present.yml
          vars:
            profile: "{{ item }}"
          loop:
            - "{{ controller_profile }}"
            - "{{ port1_profile }}"
            - "{{ port2_profile }}"

        - name: Runtime checks for booted systems
          when: __network_is_booted | bool
          block:
            - name: "** TEST check polling interval"
              command: grep 'Polling Interval'
                      /proc/net/bonding/{{ controller_device }}
              register: result
              until: "'110' in result.stdout"
              changed_when: false
            - name: "** TEST check IPv4"
              command: ip -4 a s {{ controller_device }}
              register: result
              until: "'192.0.2' in result.stdout"
              retries: 20
              delay: 2
              changed_when: false
            - name: "** TEST check IPv6"
              command: ip -6 a s {{ controller_device }}
              register: result
              until: "'2001' in result.stdout"
              retries: 20
              delay: 2
              changed_when: false

        # These are primarily interesting for non-booted systems; but let's
        # check on booted systems too, to ensure the assertions are valid
        - name: NM Config file checks
          when: network_provider != "initscripts"
          block:
            - name: Read controller config
              slurp:
                src: "/etc/NetworkManager/system-connections/{{ controller_profile }}.nmconnection"
              register: controller_config_b64

            - name: Check controller config
              assert:
                that:
                  # [connection]
                  - "'id=' + controller_profile in controller_config"
                  - "'type=bond' in controller_config"
                  - "'interface-name=' + controller_device in controller_config"
                  # [bond]
                  - "'mode=active-backup' in controller_config"
                  - "'miimon=110' in controller_config"
                  # [ipv4]
                  - "'method=auto' in controller_config"
                  - "'route-metric=65535' in controller_config"
                fail_msg: "{{ controller_profile }} is bad: {{ controller_config }}"
              vars:
                controller_config: "{{ controller_config_b64.content | b64decode }}"

            - name: Read port configs
              loop:
                - { name: "{{ port1_profile }}", iface_name: "{{ dhcp_interface1 }}" }
                - { name: "{{ port2_profile }}", iface_name: "{{ dhcp_interface2 }}" }
              slurp:
                src: "/etc/NetworkManager/system-connections/{{ item.name }}.nmconnection"
              register: port1_config_b64

            - name: Check port configs
              loop: "{{ port1_config_b64.results }}"
              vars:
                port_config: "{{ item.content | b64decode }}"
              assert:
                that:
                  # [connection]
                  - "'id=' + item.item.name  in port_config"
                  - "'type=ethernet' in port_config"
                  # that points to UUID of controller, a bit cumbersome to match; but let's assume nmcli DTRT
                  - "'controller=' in port_config"
                  - "'interface-name=' + item.item.iface_name in port_config"
                  - "'port-type=bond' in port_config"
                  - "'[ipv4]' not in port_config"
                  - "'[ipv6]' not in port_config"
                fail_msg: "{{ item.item.name }} is bad: {{ port_config }}"

      always:
        - name: Clean up the test devices and the connection profiles
          tags:
            - "tests::cleanup"
          block:
            - name: Import network role
              import_role:
                name: linux-system-roles.network
              vars:
                network_connections:
                  - name: "{{ port2_profile }}"
                    persistent_state: absent
                    state: down
                  - name: "{{ port1_profile }}"
                    persistent_state: absent
                    state: down
                  - name: "{{ controller_profile }}"
                    persistent_state: absent
                    state: down
              failed_when: false
            - name: Delete the device '{{ controller_device }}'
              command: ip link del {{ controller_device }}
              failed_when: false
              changed_when: false
              when: __network_is_booted | bool
            - name: Import the task 'remove_test_interfaces_with_dhcp.yml'
              import_tasks: tasks/remove_test_interfaces_with_dhcp.yml
            - name: "Restore the /etc/resolv.conf for initscript"
              command: mv -vf /etc/resolv.conf.bak /etc/resolv.conf
              when:
                - network_provider == "initscripts"
              changed_when: false
            - name: Verify network state restored to default
              include_tasks: tasks/check_network_dns.yml
              when: __network_is_booted | bool
